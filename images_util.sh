#!/bin/bash

# Copyright (c) 2025 Free Software Foundation, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

#
# This program manages common tasks for attempting to build Lineage
# for multiple devices. It assumes a directory tree of vendor/model
# for the images, which contain the zip files of Lineage install packages.
#

# Adjust these paths to customize.
images="/work/Lineage-images"
if test x"${LINEAGE}" = x; then
    lineage="/work/Lineage-22.2"
else
    lineage="${LINEAGE}"
fi
# dryrun="echo DEBUG: "
dryrun=""

version=22.2
tmp="/tmp/xx.$$"
log="lineage.log"
# The list of devices as generated by the link function.
devlist="$(dirname $0)/librephone/devices.lst"
#devlist="/tmp/devices.lst"
total=$(wc -l ${devlist} | cut -d ' ' -f 1)
verbose=0
# Use arrays to map vendor, build, and model names between them.
declare -Ag bldnames
declare -Ag modnames
declare -Ag vendnames

rm -f ${log}

# Simple error reporting function
errmsg() {
    echo "ERROR: $1"
    echo "ERROR: $1" >> ${log}
}

# Simple warning reporting function
warnmsg() {
    if test ${verbose} -gt 0; then
       echo "WARNING: $1"
    fi
    echo "WARNING: $1" >> ${log}
}

# Simple logging function
logmsg() {
    if test ${verbose} -gt 0; then
       echo "$1"
    fi
    echo "$1" >> ${log}
}

# Simple mapping between build names and device model names.
load_devlist() {
    while read -r line; do
	vendor=$(echo ${line} | cut -d ':' -f 1)
	build=$(echo ${line} | cut -d ':' -f 2)
	model=$(echo ${line} | cut -d ':' -f 3)
	vendnames[${build}]=$(echo ${vendor} | tr '[:upper:]' '[:lower:]')
	bldnames[${build}]=${model}
	modnames[${model}]=${build}
    done < ${devlist}
}

# Construct the path to files
path() {
    build=${1}
    echo "${vendnames[${build}]}/${bldnames[${build}]}"
}

# Remove all files left from file extraction
remove() {
    builds=${1:-${modnames[*]}}
    for i in ${builds}; do
	dir=$(path $i)
	logmsg "Removing junk files from ${dir}"
	${dryrun} sudo extractor -v -r ${dir}
    done
}

# Unmount file systems
unmount() {
    builds=${1:-${modnames[*]}}
    for i in ${builds}; do
	dir=$(path $i)
	logmsg "Unmounting ${images}/${dir}"
	${dryrun} sudo extractor -v -u ${images}/${dir}
    done
}

# Import files into a database
import_blobs() {
    logmsg "Importing ${total} devices..."
    ${dryrun} import-device -b
   builds=${1:-${modnames[*]}}
    for i in ${builds}; do
	dir=$(dirname $(path ${i}))
	# clone ${i}
	# dir="$(dirname $(path $i))"
	blddir="${images}/blobs/${dir}/${i}"
	# blddir="${images}/${dir}/${i}"
	${dryrun} import-device -v -i ${blddir}
	${dryrun} extractor -v -u ${blddir}
	total=$(expr ${total} - 1)
	logmsg "${total} devices left to build..."
    done
}

# Extract files from the unzipped install package
extract() {
    logmsg "Extracting files from ${total} devices..."
    builds=${1:-${modnames[*]}}
    for i in ${builds}; do
	dir=$(path ${i})
	logmsg "Extracting files from ${images}/${dir}"
	# See if it's already been unzipped
	if test ! -e "${images}/${dir}/payload.bin"; then
	    # ${dryrun} extractor -v -r ${images}/${dir}
	    ${dryrun} extractor -v -z ${images}/${dir}
	fi
	# When Lineage extracts files, it deletes the system.img
	# files. So if this exists, we don't need to extract everything
	# again. A small time saver when processing all 210 devices.
	if test ! -e "${dir}/system.img"; then
	    # ${dryrun} extractor -v -r ${images}/${dir}
	    ${dryrun} extractor -v -e ${images}/${dir}
	fi
	${dryrun} extractor -v -u ${images}/${dir}
	total=$(expr ${total} - 1)
	logmsg "${total} devices left to build..."
    done
}

# Extract files from the unzipped install package
clone() {
    logmsg "Cloning mounted files from ${total} devices..."
    builds=${1:-${modnames[*]}}
    for i in ${builds}; do
	blddir=$(path ${i})
	model=$(basename ${blddir})
	logmsg "Extracting proprietary files from ${blddir}"
	# blddir="$(dirname ${blddir})/${build}"
	${dryrun} extractor -v -z ${images}/${blddir}
	${dryrun} extractor -v -e ${images}/${blddir}
	${dryrun} sudo extractor -v -c ${images}/${blddir} -o ${images}/blobs
	total=$(expr ${total} - 1)
	logmsg "${total} devices left to build..."
    done
}

# When changing vendors, we have to remove files from other vendors because'
# the build system globs directories, so they wind up causing depenency issues
# at build time.
change_vendor() {
    save="common|generic|google|google_car|lineage|qcom|sample"
    olddirs=$(find device -mindepth 1 -maxdepth 1 -type d)
    for devdir in ${olddirs}; do
	if test $(echo ${devdir} | grep -Ec ${save}) -eq 0; then
	    ${dryrun} rm -fr ${devdir}
	fi
    done
    save="codeaurora|crowdin|lineage|qcom"
    olddirs=$(find vendor -mindepth 1 -maxdepth 1 -type d)
    for devdir in ${olddirs}; do
	if test $(echo ${devdir} | grep -Ec ${save}) -eq 0; then
	    ${dryrun} rm -fr ${devdir}
	fi
    done
    logmsg "Running git reset..."
    ${dryrun} repo forall -c "git reset --hard"
    # repo forall -c "git gc"
    ${dryrun} rm -f .repo/local_manifests/roomservice.xml
}

# Attempt to build a device
build() {
    logmsg "Building ${total} devices..."
    # Load Lineage setup
    source build/envsetup.sh

    builds=${1:-${modnames[*]}}
    for build in ${builds}; do
	dir=$(path ${build})
	vendor="$(echo ${dir} | cut -d '/' -f 1)"
	model="$(echo ${dir} | cut -d '/' -f 2)"
	# these cause trouble at build time, ie... mka -j 8
	logmsg "--------------------------------"
	# dir="${lineage}/${vendor}/${build}"
	tmpfile="/tmp/build.${build}"
	logmsg "Configuring ${vendor} ${model} ${build}..."
	if test ! -e  device/${vendor}/${build}; then
	   ${dryrun} breakfast ${build} eng >& ${tmpfile}
	   if test $(grep -Ec "-vendor.mk does not exist" ${tmpfile}) -gt 0; then
	       errmsg "Breakfast ${build} failed!"
	       continue
	   fi
	   logmsg "Breakfast first pass sucessful for ${build}"
	fi
	if test ! -e "device/${vendor}/${build}"; then
	    errmsg "Breakfast failed in for device/${vendor}/${build}"
	    continue
	fi
	logmsg "Extracting blobs from ${vendor} ${model} ${build}..."
	if test x"${dryrun}" = x; then
	    if test ! -e x"${images}/${vendor}/${build}/vendor.img"; then
		# warnmsg "Files haven't been extracted for ${build}!"
		${dryrun} extractor -v -e ${images}/${vendor}/${build} 
	    fi
	    pushd device/${vendor}/${build}
	    ./extract-files.py ${images}/${vendor}/${build} >& ${tmpfile}
	    if test $(grep -c "Permission denied" ${tmpfile}) -gt 0; then
		warnmsg "Permission denied error for ${build}"
	    fi
	    if test $(grep -c "failed to build" ${tmpfile}) -gt 0; then
		warnmsg "Failed to build for ${build}"
	    fi
	    if test $(grep -c "Failed to run command" ${tmpfile}) -gt 0; then
		warnmsg "Command failed to run for ${build}"
	    fi
	    if test $(grep -c "Some files failed to process" ${tmpfile}) -gt 0; then
		warnmsg "Some files don't exist6 for ${build}"
	    fi
	    if test $(grep -c ^"Traceback " ${tmpfile}) -gt 0; then
		warnmsg "Script failed to run for ${build}"
	    fi
	    if test $(grep -c "KeyboardInterrupt" ${tmpfile}) -gt 0; then
		warnmsg "User killed for ${build}"
	    fi
	    if test $(grep -Ec "failed to build|Failed to run command|KeyboardInterrupt|Some files failed to process|No such file or directory|Permission denied|Traceback" ${tmpfile}) -gt 0; then
		errmsg "Couldn't extract blobs for ${vendor} ${device} ${build}"
		popd
		continue
	    else
		logmsg "Extracting files was sucessful for ${build}"
	    fi
	    # rm -f ${tmpfile}
	else
	    logmsg "Debug mode is on, so no file extraction"
	fi
	popd

	${dryrun} breakfast ${build} eng
	logmsg "Breakfast second pass sucessful for ${build}"
	# Clean up the old build
	# rm -fr vendor/${vendor}/${build}
	# logmsg "Building ${vendor} ${device} ${build}..."
	# mka -j 8 >& ${tmpfile}
	# if test $(tail -1 ${tmpfile} | grep -c "succeeded") -eq 0 -a x"${dryrun}" = x; then
	#     errmsg "${vendor} ${device} ${build} failed to build"
	# else
	#     logmsg "${vendor} ${device} ${build} built successfully!"
	# fi
	# ${dryrun} taskset -c 0-7 brunch ${build}
	total=$(expr ${total} - 1)
	logmsg "${total} devices left to build..."
    done
}

# Symbolically link the build name to the device name
link() {
    find ${images} -name lineage*${version}*.zip > ${tmp}

    rm -f ${devlist}
    touch ${devlist}
    while read -r line; do
	dir=$(dirname ${line})
	vendor=$(echo ${line} | cut -d '/' -f 4)
	build=$(basename ${line} | cut -d '-' -f 5)
	model=$(basename ${dir})
	logmsg "Linking ${build} to ${dir} in $PWD"
	${dryrun} ln -sf ${dir} ${images}/${vendor}/${build}
	echo "${vendor}:${build}:${model}" >> /tmp/xx
    done < ${tmp}
    sort /tmp/xx | uniq > ${devlist}

    # FIXME: where is this link coming from ? Delete
    # them till fixed.
    find . -mindepth 3 -type l -exec rm {} \\;
}

# Display help messages
usage() {
    echo "--help (-h): Display help screen"
    echo "--verbose (-v): Verbose output"
    echo "--dryrun (-d): Just dry run,don't execute anything"
    echo "--remove (-r): Remove all generated files"
    echo "--link (-l): Link build names to device name"
    echo "--extract (-e): Extract files from package"
    echo "--clone (-c): Clone files"
    echo "--unmount (-u): Unmount all device filesystems"
    echo "--build (-b): Build packages"
    echo "--import (-i): Import blobs into a database"
    echo "--file (-f): Process a specific file instead of all devices, for debugging"
    echo "--all (-a): Do everything, which takes a long time"
    echo "--change (-ch): Change vendor builds"
   }

# A command is required
if test $# -eq 0; then
    usage
    exit
fi

# Create the device list if it doesn't exist.
if test ! -e ${devlist}; then
    link
fi
# Load the list of device metadata
load_devlist

device=""
# Process command line arguments
while test $# -gt 0; do
    case "$1" in
	-v|--verbose)
	    verbose=1
	    ;;
	-h|--help)
	    usage
	    exit 0
	    ;;
	-d|--dryrun)
	    dryrun="echo DEBUG: "
	    verbose=1
	    log="lineage-debug.log"
	    ;;
	-f|--file)
	    shift
	    device=$1
	    total=1
	    ;;
	-r|--remove)
	    remove ${device}
	    ;;
	-l|--link)
	    link
	    ;;
	-e|--extract)
	    extract ${device}
	    ;;
	-u|--unmount)
	    unmount ${device}
	    ;;
	-b|--build)
	    build ${device}
	    ;;
	-i|--import)
	    import_blobs ${device}
	    ;;
	-c|--clone)
	    clone ${device}
	    unmount
	    ;;
	-ch|--change)
	    change_vendor ${device}
	    ;;
	-a|--all)
	    echo "This may take hours or days to complete!"
	    link
	    extract
	    build
	    ;;
    esac
    shift
done
